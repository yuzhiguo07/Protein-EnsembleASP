import os
import argparse
import numpy as np
import random
import warnings
# warnings.filterwarnings('error')

# parse arugments
parser = argparse.ArgumentParser(description='Calculate PSSM from MSA generated by Jackhmmer')

parser.add_argument('--aln_path', required=True, help='path to the *.aln file')
parser.add_argument('--save_path', required=True, help='path to save file path')
parser.add_argument('--method', required=True, help='PSSM calculate method: 0/1/2')
parser.add_argument('--ss_path', required=False, help='path to the ss file')
args = parser.parse_args()

ss_path = args.ss_path
aln_path = args.aln_path
save_path = args.save_path
method = args.method # 0/1/2
max_raw_num = 1000

seq_list = ['A', 'C', 'E', 'D', 'G', 'F', 'I', 'H', 'K', 'M', 'L', 'N', 'Q', 'P', 'S', 'R', 'T', 'W', 'V', 'Y', 'X','*','-']
ss_list = ['L', 'B', 'E', 'G', 'I', 'H', 'S', 'T',' ']

ss_index_dict = {}
for index, ss in enumerate(ss_list):
    ss_index_dict[ss] = index

if ss_path is not None:
    ss_dict = {}
    with open(ss_path) as f:
        lines = f.readlines()
        for line in lines:
            # seq = line.split(',')[2].strip()
            # ss = line.split(',')[3].strip()
            seq = line.split(',')[0].strip()
            ss = line.split(',')[1].strip()
            ss_dict[seq] = ss

seq_dict = {}

for i, seq_k in enumerate(seq_list):
    seq_dict[seq_k] = i

def is_float(s):
    try:
        a = float(s)
    except:
        return False
    return True

matrix_dict = {}

with open(aln_path) as f:
    i = 0
    lines = f.readlines()
    for index, line in enumerate(lines):
        if index != len(lines) -1 and is_float(lines[index+1]):
            i += 1
            seq = line.strip()
            if seq in matrix_dict:
                print('!!!!!!!!!!!!!!')
                print(seq)
                # wol.write(seq+'\n')
            raw_num = int(float(lines[index+1]))
            if raw_num < 1:
                print("Protein_seq: {} didn't match any protein in Database".format(seq))
                continue
            raws = lines[index+2 : index+2+raw_num]
            if raw_num > max_raw_num:
                raws = raws[:max_raw_num]
            # if random_ratio != 1:
            #     raws = random.sample(raws, int(len(raws) * random_ratio))
            matrix = [] # the i'th line is the msa_feature list for the i'th char in the seq
            for idx in range(len(seq)):
                in_matrix = []
                for raw in raws:
                    try:
                        in_matrix.append(seq_dict[raw[idx]])
                    except:
                        in_matrix.append(seq_dict['X'])
                matrix.append(in_matrix)
            matrix_dict[seq] = matrix
            print('{}/{}'.format(index+1, len(lines)), end='\r')


key_list = list(matrix_dict.keys())

def one_hot(char, dict_list):
    one_hot_list = []
    for item in dict_list:
        if char == item:
            one_hot_list.append(1.0)
        else:
            one_hot_list.append(0.0)
    return one_hot_list
def get_pssm(matrix_dict, random_ratio):
    # seq_list = ['A', 'C', 'E', 'D', 'G', 'F', 'I', 'H', 'K', 'M', 'L', 'N', 'Q', 'P', 'S', 'R', 'T', 'W', 'V', 'Y', 'X','*','-']
    basic_pssm_dict = {}
    for index, key in enumerate(matrix_dict):

        num_class = len(seq_list) - 2
        key_arr = [seq_dict[k] for k in key]
        one_hot_fearture = np.eye(num_class)[key_arr]
        
        feat_matrix = []
        randnum = random.randint(0,100)
        
        matrix = np.array(matrix_dict[key]) # .astype(np.int64)
        m_line_num = len(matrix_dict[key][0])
        if random_ratio != 1:
            new_num = int(m_line_num * random_ratio)
            index_lines = np.array([i for i in range(m_line_num)])
            index_random_list = np.random.choice(index_lines, new_num, False)
            matrix = np.transpose(np.transpose(matrix)[index_random_list, :])
            m_line_num = new_num

        frequency_matrix = np.apply_along_axis(lambda x: np.bincount(x, minlength=len(seq_list)), axis=1, arr=matrix)



        frequency_matrix = np.split(frequency_matrix.astype(np.float64), [-2],axis= 1)[0] # split * and -
        pseufocount = 1.0
        N = m_line_num

        score = (frequency_matrix + pseufocount)/(N + 20 * pseufocount)
        if method == 0 or method == 1:
            if method == 1:
                bf_list = np.array([0.0 for i in range(len(seq_list))])
                for row in matrix:
                    bf_list += np.bincount(row, minlength=len(seq_list))
                # print(bf_list)
                bf_list = np.split(bf_list.astype(np.float64), [-2])[0]
                b_all = 0
                for b in bf_list:
                    b_all += b
                bf_list_avg = bf_list / b_all
                bf_list_avg = bf_list_avg.tolist()
                bf = []
                for _ in range(score.shape[0]):
                    bf.append(bf_list_avg)
                bf = np.array(bf)

                score = np.log(score/bf) # pssm = log(score/0.05)   pssm = log(score/bf)
                score = 1 / (1 + np.exp(-score)) # pssm = Sigmoid(pssm)  s = 1 / (1 + np.exp(-c))

        if method == 2:
            B = 0.1
            bf_list = np.array([0.0 for i in range(len(seq_list))])
            for row in matrix:
                bf_list += np.bincount(row, minlength=len(seq_list))
            # print(bf_list)
            bf_list = np.split(bf_list.astype(np.float64), [-2])[0]
            b_all = 0
            for b in bf_list:
                b_all += b
            bf_list_avg = bf_list / b_all
            bf_list_avg = bf_list_avg.tolist()
            bf = []
            for _ in range(score.shape[0]):
                bf.append(bf_list_avg)
            bf = np.array(bf)
            score = (frequency_matrix + B*bf)/(N + B)



        feature_matrix = np.concatenate((one_hot_fearture, score), axis=1)

        # basic_pssm_dict[key] = feature_matrix
        basic_pssm_dict[key] = feature_matrix.tolist()

    return basic_pssm_dict
def padding(data_max_text_len, matrix, feature_size):
    mask_dict = {}
    mask_list = [0.0 for _ in range(int(feature_size/2))] + [1.0 for _ in range(int(feature_size/2))]
    padding_list = [0.0 for _ in range(feature_size)]
    for key in matrix:
        mask_dict[key] = []
        key_len = len(key)
        padding_num = data_max_text_len - key_len
        for _ in range(key_len):
            mask_dict[key].append(mask_list)
        for _ in range(padding_num):
            matrix[key].append(padding_list)
            mask_dict[key].append(padding_list)
    return matrix, mask_dict


# data_matrix_dict = get_pssm(matrix_dict, config.random_ratio)
matrix_dict = get_pssm(matrix_dict, 1)
matrix_dict, label_mask_dict = padding(700, matrix_dict, 42)
print()



with open(save_path, 'w') as w:
    
    for index, key in enumerate(matrix_dict):
        w.write('{}\n'.format(700))
        feat = matrix_dict[key]
        for row in feat:
            for r in row:
                w.write('{} '.format(r))
            w.write('\n')
        if ss_path is not None:
            for s in ss_dict[key]:
                w.write('{}\n'.format(ss_index_dict[s]))
            ss_pad_num = 700 - len(ss_dict[key])
        for i in range(ss_pad_num):
            w.write('{}\n'.format(8))

        print('{}/{}'.format(index+1, len(matrix_dict)), end='\r')






